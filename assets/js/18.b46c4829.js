(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{415:function(n,a,t){"use strict";t.r(a);var e=t(56),s=Object(e.a)({},(function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"js-变量对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js-变量对象"}},[n._v("#")]),n._v(" JS 变量对象")]),n._v(" "),t("h2",{attrs:{id:"变量对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#变量对象"}},[n._v("#")]),n._v(" 变量对象")]),n._v(" "),t("ul",[t("li",[n._v("变量对象是执行上下文的重要属性之一")]),n._v(" "),t("li",[n._v("变量对象是与执行上下文相关的数据作用域，存储了上下文定义的变量和函数")]),n._v(" "),t("li",[n._v("下面我们主要分享全局作用域和函数作用域")])]),n._v(" "),t("h2",{attrs:{id:"全局变量对象vo"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#全局变量对象vo"}},[n._v("#")]),n._v(" 全局变量对象VO")]),n._v(" "),t("p",[n._v("我们先理解一个全局对象")]),n._v(" "),t("ul",[t("li",[n._v("全局对象是预定义的对象，比如js内部已经定义好的全局属性：NaN、undefined、infinity，还有全局函数：parseInt()、String()、decodeURLIComponent(),eval(),isNaN()等,这些变量和函数我们在浏览器里面都可以直接使用")]),n._v(" "),t("li",[n._v("在顶层的javascript代码中，可以通过this引用全局对象")]),n._v(" "),t("li",[n._v("全局对象其实就是全局的变量对象，全局对象是Object构造函数实例化的一个对象")]),n._v(" "),t("li",[n._v("在浏览器中,全局对象有window属性指向本身")]),n._v(" "),t("li",[n._v("下面我们可以伪代码写出全局对象的变量对象的原型")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var num = 12\nfunction f(){}\n\n//variable object VO 可以表示为\n\nVO = {\n    ...内置属性\n    num,\n    f:referce to function(){}\n}\n")])])]),t("h2",{attrs:{id:"函数变量对象ao"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数变量对象ao"}},[n._v("#")]),n._v(" 函数变量对象AO")]),n._v(" "),t("ul",[t("li",[n._v("在函数上下文中，我们使用活动对象 activity object 来表示")]),n._v(" "),t("li",[n._v("其实活动对象和变量对象是一个东西，变量对象是内部引擎实现的，当一个函数执行的时候，创建一个对应的函数上下文，这个时候执行上下文的变量对象被激活，所以称为活动对象")]),n._v(" "),t("li",[n._v("函数的执行上下文可以分为两个阶段：进入执行上下文、执行\n1、函数进入执行上下文，这个时候代码还没执行，先创建活动对象，这个时候活动对象包含")]),n._v(" "),t("li",[n._v("函数所有的形参和实参结合")]),n._v(" "),t("li",[n._v("函数声明：指向对应声明的函数，有同名属性会覆盖（优先级最高，同全局上下文）")]),n._v(" "),t("li",[n._v("变量声明：值为undefined,与声明的形参和函数同名不会干扰这些属性\n下面是一个demo")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function foo(a){\n    var b = 'b'\n    function c(){}\n    var d = function(){}\n    d = 3\n}\nfoo(1)\n")])])]),t("p",[n._v("先进入执行上下文，这个时候的活动对象AO为")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("AO =  {\n    arguments:{\n        0:1,\n        length:1\n    },\n    a:1,\n    b:undefined,\n    c:function (){}\n    d:undefined\n}\n\n")])])]),t("p",[n._v("foo(1)开始执行，修改赋值,这个时候AO")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("AO =  {\n    arguments:{\n        0:1,\n        length:1\n    },\n    a:1,\n    b:'b',\n    c:function (){}\n    d:3\n}\n\n")])])]),t("p",[n._v("上面的代码综合来总结可以整理为\n1、 全局上下文的变量对象初始化为全局对象\n2、 函数函数上下文变量对象初始化为arguments对象\n3、 函数进去上下文时候，活动对象会添加会进行形参、变量、函数的初始化\n4 、函数开始执行时候，修改活动对象的属性")]),n._v(" "),t("h2",{attrs:{id:"思考题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#思考题"}},[n._v("#")]),n._v(" 思考题")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v(" function print(){\n     console.log(a) //Uncaught ReferenceError: a is not defined\n     a = 1\n }\n print()\n\n 解析：这个时候 a不是var声明的不存在提升也不在AO中，然后就从全局中找，全局中还没有就开始报错了\n\n function f2(){\n     a = 2 //非严格模式是是隐式全局变量\n     console.log(a) //2\n }\n f2()\n\n 解析：这个时候a在AO中也拿不到，但是赋值给全局了，所以打印2\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("console.log(foo) // function foo(){}\nvar foo = 12\nfunction foo(){}\n")])])]),t("p",[n._v("解析：进入执行上下时候，会先处理函数声明，如果存在相同的属性会直接覆盖")])])}),[],!1,null,null,null);a.default=s.exports}}]);
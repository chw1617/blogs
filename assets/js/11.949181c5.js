(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{408:function(t,a,n){"use strict";n.r(a);var s=n(56),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"js-闭包"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js-闭包"}},[t._v("#")]),t._v(" JS 闭包")]),t._v(" "),n("h2",{attrs:{id:"闭包概念"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#闭包概念"}},[t._v("#")]),t._v(" 闭包概念")]),t._v(" "),n("ul",[n("li",[t._v("MDN定义：闭包是指那些能够访问自由变量的函数")]),t._v(" "),n("li",[t._v("自由变量：在函数中使用的，既不是函数的参数也不是函数的局部变量")]),t._v(" "),n("li",[t._v("那么我们可以得出闭包的条件是：闭包 =  函数 + 函数能够访问自由变量")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var value = 1\nfunction print(){\n    console.log(value)\n}\nprint()\n")])])]),n("p",[t._v("解析：上面的例子中print是一个函数，同时print中也访问的自由变量value,那这不就形成了一个闭包，所以在JavaScript权威指南中就指出，所有的JavaScript函数都属于闭包")]),t._v(" "),n("ul",[n("li",[t._v("这个理解和我们平时的认知有些差别，其实上面的是理论上的闭包，还有实践上的闭包")]),t._v(" "),n("li",[t._v("理论角度：js中所有的函数，在函数创建的时候就已经保存了上层的上下文的变量对象到自己作用域中，访问最外层的全局变量也是，访问全局变量也是在访问自由变量")]),t._v(" "),n("li",[t._v("实践角度：1、即使父作用域执行完成被销毁了，它依然存在（被保存到了外部），2、函数内部中访问了自由变量")]),t._v(" "),n("li",[t._v("我在作用链的那一章也进行了解析，下面再来贴一次")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var scope = 'global scope'\nfunction f1(){\n    var scope = 'local scope'\n    function f2(){\n        return scope\n    }\n    return f2\n}\nf1()()\n")])])]),n("p",[t._v("1、这段代码执行，先创建全局的上下文栈，这个时候上下文栈为")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("ECStack = [globalContext]\n")])])]),n("p",[t._v("2、进入全局的上下文的同时，函数f1也被定义，f1的scope会将上层的作用域链到内部[[scope]]")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("globalContext = {\n    VO:{\n        scope,\n        f1\n    },\n    scope:[globalContext.VO],\n    this:globalContext.VO\n}\n\nf1.[[scope]] = [globalContext.VO]\n\n")])])]),n("p",[t._v("3、执行函数f1，创建f1的执行上下文，并入栈")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("ECStack = [f1Context,globalContext]\n\n")])])]),n("p",[t._v("4、进入函数f1的执行上下文，创建f1.AO,同时函数f2也被定义,并将父作用域链保存到[[scope]]")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("f1Context = {\n    AO:{\n        arguments:{},\n        scope:undefiend,\n        f2:function(){}\n    },\n    scope:[AO,globalContext.VO],\n    this:undefined\n}\n\nf2.[[scope]] = [f1Context.AO,globalContext.VO]（闭包根本）\n\n")])])]),n("p",[t._v("5、f1函数开始执行，改变f1上下文的AO,同时将f2返回到外部(从而产生闭包)")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("f1Context = {\n    AO:{\n        arguments:{},\n        scope:'local scope',\n        f2:function(){}\n    },\n    scope:[AO,globalContext.VO],\n    this:undefined\n}\n\n")])])]),n("p",[t._v("6、f1执行完成，退出上下文执行栈")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("ECStack = [globalContext]\n")])])]),n("p",[t._v("7、函数f2接着执行，开始进入f2的执行栈")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("ECStack = [f2Context,globalContext]\nf2Context = {\n    AO:{\n        arguments:{},\n    },\n    scope:[AO,f1Context.AO,globalContext.VO],\n    this:undefined\n}\n\n")])])]),n("p",[t._v("8、f2执行,自己AO中没有找到，沿这作用域查找scope为local scope，最后退出上下文栈")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("ECStack = [globalContext]\n")])])]),n("h2",{attrs:{id:"闭包的作用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#闭包的作用"}},[t._v("#")]),t._v(" 闭包的作用")]),t._v(" "),n("p",[t._v("1、保存局部变量到内存中\n2、让外部的函数可以访问函数内部的变量，相当于开辟了一个桥梁")]),t._v(" "),n("h2",{attrs:{id:"闭包应用场景"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#闭包应用场景"}},[t._v("#")]),t._v(" 闭包应用场景")]),t._v(" "),n("p",[t._v("1、解决块级作用域的问题")]),t._v(" "),n("h2",{attrs:{id:"思考题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#思考题"}},[t._v("#")]),t._v(" 思考题")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var stack = []\nfor(var i = 0;i<3;i++){\n    stack[i] = function(){\n        console.log(i)\n    }\n}\nstack[0]()\nstack[1]()\nstack[2]()\n")])])]),n("p",[t._v("上面的程序输出都是3\n解析：\n1、执行到stack[0]的时候，此时全局的上下文变量对象为glabloContext,同时也stack里面定义的函数也都保存了该变量对象到[[scope]]")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("glabloContext = {\n    VO:{\n        data:[...],\n        i:3\n    }\n}\nstack[0].[[scope]] = [glabloContext.VO]\nstack[1].[[scope]] = [glabloContext.VO]\nstack[2].[[scope]] = [glabloContext.VO]\n")])])]),n("p",[t._v("2、开始进入stack[0]执行前，先创建执行上下文，这个时候作用域链变成了")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("stack[0]Context = {\n    AO:{\n        arguments:{}\n    },\n    scope: [AO,glabloContext.VO]\n}\n")])])]),n("p",[t._v("3、stack[0]开始执行的时候，发现AO没有找到i，就往VO中找到了i=3,data[1]和data[2]也是一样")]),t._v(" "),n("p",[t._v("如果需要输出0,1,2,下面我们修改成闭包来看看")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var stack = []\nfor(var i = 0;i<3;i++){\n    stack[i] = (function(i){\n       return function(){\n        console.log(i)\n       }\n    })(i)\n}\nstack[0]()\nstack[1]()\nstack[2]()\n")])])]),n("p",[t._v("1、执行到stack[0]的时候，此时全局的VO为")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("glabloContext = {\n    VO:{\n        data:[...],\n        i:3\n    }\n}\n")])])]),n("p",[t._v("2、不过这里多了一步立即执行函数，创建了匿名函数的上下文，也被保存到stack[0]的stack的[[scope]]")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("匿名Context = {\n   AO:{\n    arguments:{\n        0:0,\n        length:1\n    },\n    i:0\n   },\n   scope:[glabloContext.VO]\n}\nstack[0].[[scope]] = [匿名Context.AO,glabloContext.VO]\n\n")])])]),n("p",[t._v("3、进入stack[0]执行的前，创建上下文")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("stack[0]Context = {\n    AO:{\n        arguments:{}\n    },\n    scope:[AO,匿名Context.AO,glabloContext.VO]\n}\n\n")])])]),n("p",[t._v("4、执行stack[0],自己AO没有找到，就沿这链往上找的匿名AO,i=0,所以就输出0，data[1]和data[2]也是")])])}),[],!1,null,null,null);a.default=e.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{413:function(t,a,e){"use strict";e.r(a);var s=e(56),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"js-作用域链"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js-作用域链"}},[t._v("#")]),t._v(" JS 作用域链")]),t._v(" "),e("h2",{attrs:{id:"作用域链"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#作用域链"}},[t._v("#")]),t._v(" 作用域链")]),t._v(" "),e("ul",[e("li",[t._v("函数的作用域：当查找变量的时候，会先从当前的上下文执行栈的变量对象中查找，如果没有找到，就从父级（词法上的作用域）的上下文的变量对象中查找，直到查找到全局上下文的变量对象，这样由多一个执行上下文变量对象组成的链表就是作用域链")]),t._v(" "),e("li",[t._v("下面我们从函数定义和执行的时候，作用域链的变化是怎么样的")])]),t._v(" "),e("h2",{attrs:{id:"函数定义时"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数定义时"}},[t._v("#")]),t._v(" 函数定义时")]),t._v(" "),e("p",[t._v("我们在js词法作用域分析的时候就已经解析过，函数在定义的时候就已经确定了函数的作用域")]),t._v(" "),e("ul",[e("li",[t._v("这个是因为函数有一个[[scope]]属性，函数定义的时候，保存了所有的父变量对象")]),t._v(" "),e("li",[t._v("下面demo可以看看")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function f1(){\n    function f2(){}\n}\nf1()\n解析：\n函数f1定义时：f1.[[scope]] = [globalContext.vo]\n函数f1执行时候：f2定义： f2.[[scope]] = [f1Context.AO,globalContext.vo]\n")])])]),e("h2",{attrs:{id:"函数执行时"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数执行时"}},[t._v("#")]),t._v(" 函数执行时")]),t._v(" "),e("p",[t._v("还是上面的例子")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function f1(){\n    function f2(){}\n}\nf1()\n解析：\n函数f1执行时候：f2定义： f2.[[scope]] = [f1Context.AO,globalContext.VO]\nf1的scope变成：f1.[[scope]] = [f1Context.AO,globalContext.VO]\n")])])]),e("h2",{attrs:{id:"具体综合分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#具体综合分析"}},[t._v("#")]),t._v(" 具体综合分析")]),t._v(" "),e("p",[t._v("还是直接具体分析代码，")]),t._v(" "),e("ul",[e("li",[t._v("解析js的执行过程中作用域链、执行上下文栈、变量对象的变化")]),t._v(" "),e("li",[t._v("闭包一直都是作用域的问题，这个也会讲解到闭包的产生（函数定义的时候就将上层的作用域保存到[[scope]],同时上层作用域的变量）")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var scope = 'global scope'\nfunction f1(){\n    var scope = 'local scope'\n    function f2(){\n        return scope\n    }\n    return f2\n}\nf1()()\n")])])]),e("p",[t._v("1、这段代码执行，先创建全局的上下文栈，这个时候上下文栈为")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("ECStack = [globalContext]\n")])])]),e("p",[t._v("2、进入全局的上下文的同时，函数f1也被定义，f1的scope会将上层的作用域链到内部[[scope]]")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("globalContext = {\n    VO:{\n        scope,\n        f1\n    },\n    scope:[globalContext.VO],\n    this:globalContext.VO\n}\n\nf1.[[scope]] = [globalContext.VO]\n\n")])])]),e("p",[t._v("3、执行函数f1，创建f1的执行上下文，并入栈")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("ECStack = [f1Context,globalContext]\n\n")])])]),e("p",[t._v("4、进入函数f1的执行上下文，创建f1.AO,同时函数f2也被定义,并将父作用域链保存到[[scope]]")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("f1Context = {\n    AO:{\n        arguments:{},\n        scope:undefiend,\n        f2:function(){}\n    },\n    scope:[AO,globalContext.VO],\n    this:undefined\n}\n\nf2.[[scope]] = [f1Context.AO,globalContext.VO]（闭包根本）\n\n")])])]),e("p",[t._v("5、f1函数开始执行，改变f1上下文的AO,同时将f2返回到外部(从而产生闭包)")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("f1Context = {\n    AO:{\n        arguments:{},\n        scope:'local scope',\n        f2:function(){}\n    },\n    scope:[AO,globalContext.VO],\n    this:undefined\n}\n\n")])])]),e("p",[t._v("6、f1执行完成，退出上下文执行栈")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("ECStack = [globalContext]\n")])])]),e("p",[t._v("7、函数f2接着执行，开始进入f2的执行栈")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("ECStack = [f2Context,globalContext]\nf2Context = {\n    AO:{\n        arguments:{},\n    },\n    scope:[AO,f1Context.AO,globalContext.VO],\n    this:undefined\n}\n\n")])])]),e("p",[t._v("8、f2执行,自己AO中没有找到，沿这作用域查找scope为local scope，最后退出上下文栈")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("ECStack = [globalContext]\n")])])]),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("1、函数定义时候：保存了父级（书写的位置）的作用域链\n2、函数执行时候：改变活动对象、作用链、上下文栈\n\n")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{417:function(n,t,a){"use strict";a.r(t);var r=a(56),v=Object(r.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"数据结构与算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据结构与算法"}},[n._v("#")]),n._v(" 数据结构与算法")]),n._v(" "),a("h2",{attrs:{id:"数据结构分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据结构分类"}},[n._v("#")]),n._v(" 数据结构分类")]),n._v(" "),a("table",[a("thead",[a("tr",[a("th",[n._v("线性数据结构")]),n._v(" "),a("th",[n._v("非线性数据结构")])])]),n._v(" "),a("tbody",[a("tr",[a("td",[n._v("stack")]),n._v(" "),a("td",[n._v("set")])]),n._v(" "),a("tr",[a("td",[n._v("queue")]),n._v(" "),a("td",[n._v("dictionary")])]),n._v(" "),a("tr",[a("td",[n._v("link")]),n._v(" "),a("td",[n._v("tree")])]),n._v(" "),a("tr",[a("td",[n._v("arrsy")]),n._v(" "),a("td",[n._v("grap")])]),n._v(" "),a("tr",[a("td"),n._v(" "),a("td",[n._v("heap(完全二叉树)")])])])]),n._v(" "),a("h2",{attrs:{id:"时间复杂度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度"}},[n._v("#")]),n._v(" 时间复杂度")]),n._v(" "),a("ul",[a("li",[n._v("定性地描述一个算法的运行时间")]),n._v(" "),a("li",[n._v("是一个函数，用大O来表示，比如O(1)、O(n)、O(logn)")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var i = 1\ni += 1\n//时间复杂度是O(1),上面代码自会执行一次\n\nfor(var i = 0;i<n;i++){\n  console.log(n)\n}\n//时间复杂度是O(n),上代码会执行n次\n\nvar i = 1\ni += 1\nfor(var i = 0;i<n;i++){\n  console.log(n)\n}\n//时间复杂度是O(n),O(1) + O(n) = O(n) 只会统计增长次数更高的\n\nvar i = 1 \nwhile(i<n){\n  console.log(i)\n  i * = 2\n}\n//时间复杂度为O(logN)\n\nfor(var i = 0;i<n;i++ ){\n  for(var j=0;j<n;j++){\n    console.log(i,j)\n  }\n}\n//时间复杂度为O(n)*O(n)=O(n^2)\n")])])]),a("h2",{attrs:{id:"空间复杂度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#空间复杂度"}},[n._v("#")]),n._v(" 空间复杂度")]),n._v(" "),a("ul",[a("li",[n._v("算法在运行的过程中占用存储空间的大小")]),n._v(" "),a("li",[n._v("也是一个函数，用大O来表示，O(1),O(n),O(logN)")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var i = 0\ni += 1\n// O(1),只声明了单个变量，占用空间为1\n\nvar list = []\nfor(var i = 0;i<n;i++){\n  list.push(i)\n}\n// O(n)，不断往list增加n个值，那么空间大小就为n\n\nvar matrix = []\nfor(var i = 0;i<n;i++){\n  matrix[i].push([])\n  for(var j = 0;i<n;j++){\n    matrix[i] .puhs(i,j)\n  }\n}\n//O(n^2)，二维的矩阵\n\n\n")])])]),a("h2",{attrs:{id:"相关算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相关算法"}},[n._v("#")]),n._v(" 相关算法")]),n._v(" "),a("ul",[a("li",[n._v("排序算法：冒泡排序，插入排序，选择排序，归并排序，快速排序")]),n._v(" "),a("li",[n._v("搜索算法：顺序搜索、二分搜索")])]),n._v(" "),a("h2",{attrs:{id:"算法设计思想"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#算法设计思想"}},[n._v("#")]),n._v(" 算法设计思想")]),n._v(" "),a("ul",[a("li",[n._v("分而治之（分（两个独立的子问题，比如翻转二叉树），解（递归），合）")]),n._v(" "),a("li",[n._v("动态规划（分（分成两个互相重叠的子问题，比如斐波那契数列），解（递归），合 ）")]),n._v(" "),a("li",[n._v("贪心(局部最优解，从而追求最优解)")]),n._v(" "),a("li",[n._v("回溯(渐进式寻找解决问题的方法，先从一个动作出发，不可以就回溯并选择另外一个动作出发) 全排列")])])])}),[],!1,null,null,null);t.default=v.exports}}]);